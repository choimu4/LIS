<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Kakao 지도 시작하기</title>
	<link rel="stylesheet" href="assets/css/map.css" />
	<style>
	</style>
</head>

<body>
    <div class="map_wrap">
        <div id="map"></div>
        <button id="current-location-btn">현재 위치로 이동</button>
        <div id="menu_wrap" class="bg_white">
            <hr>
            <ul id="placesList"></ul>
            <div id="pagination"></div>
        </div>
    </div>
	<script type="text/javascript"
		src="//dapi.kakao.com/v2/maps/sdk.js?appkey=9f4efe1f08f0dc1b289457274270ae16&libraries=services"></script>
	<script>
		// 지도 객체와 마커 객체, 검색 서비스 객체 생성
		const map = new kakao.maps.Map(document.getElementById('map'), {
			center: new kakao.maps.LatLng(33.450701, 126.570667),
			level: 3
		});
		let marker = null;
		const placesService = new kakao.maps.services.Places();
		const infoWindow = new kakao.maps.InfoWindow({ zIndex: 1 });
		const keywords = ['코인세탁소', '코인세탁방', '무인세탁소', '무인세탁방'];
		let markers = []; // markers를 let으로 변경

		// 현재 위치 이동 버튼 클릭 이벤트 핸들러
		document.getElementById('current-location-btn').addEventListener('click', getCurrentLocation);

		// 현재 위치 가져오기
		function getCurrentLocation() {
			if (navigator.geolocation) {
				navigator.geolocation.getCurrentPosition(
					(position) => {
						const lat = position.coords.latitude;
						const lon = position.coords.longitude;
						const locPosition = new kakao.maps.LatLng(lat, lon);

						// 마커 이미지 설정
						const markerImage = new kakao.maps.MarkerImage('https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png', new kakao.maps.Size(64, 69), { offset: new kakao.maps.Point(27, 69) });

						// 마커 객체 생성 또는 위치 업데이트
						if (marker) {
							marker.setPosition(locPosition);
						} else {
							marker = new kakao.maps.Marker({ position: locPosition, image: markerImage });
							marker.setMap(map);
						}

						map.setCenter(locPosition);
						searchPlacesNearby(keywords);
					},
					(error) => alert('위치 정보를 가져오는데 실패했습니다.')
				);
			} else {
				alert('사용자의 브라우저는 Geolocation을 지원하지 않습니다.');
			}
		}

		// 주변 장소 검색
		function searchPlacesNearby(keywords) {
			const bounds = map.getBounds();
			keywords.forEach((keyword) => {
				placesService.keywordSearch(keyword, displayPlaces, { bounds });
			});
		}

		// 검색 결과 표시
		function displayPlaces(places, status) {
			if (status === kakao.maps.services.Status.OK) {
				const listEl = document.getElementById('placesList');
				const fragment = document.createDocumentFragment();
				const bounds = new kakao.maps.LatLngBounds();
				removeAllChildNodes(listEl);
				removeMarkers();

				places.forEach((place, index) => {
					const placePosition = new kakao.maps.LatLng(place.y, place.x);
					const marker = addMarker(placePosition, index);
					const itemEl = getListItem(index, place);

					bounds.extend(placePosition);

					// 마커와 리스트 항목에 mouseover, mouseout 이벤트 핸들러 등록
					(function (marker, title) {
						kakao.maps.event.addListener(marker, 'mouseover', () => displayInfoWindow(marker, title));
						kakao.maps.event.addListener(marker, 'mouseout', () => infoWindow.close());
						itemEl.onmouseover = () => displayInfoWindow(marker, title);
						itemEl.onmouseout = () => infoWindow.close();
					})(marker, place.place_name);

					fragment.appendChild(itemEl);
				});

				listEl.appendChild(fragment);
				map.setBounds(bounds);
			}
		}

		// 리스트 항목 생성
		function getListItem(index, place) {
			const el = document.createElement('li');
			el.innerHTML = `<span>${index + 1}</span> <span>${place.place_name}</span>`;
			el.className = 'item';
			return el;
		}

		// 마커 생성
		function addMarker(position, idx) {
			const marker = new kakao.maps.Marker({ position, map });
			marker.setMap(map);
			markers.push(marker); // 마커를 배열에 추가
			return marker;
		}

		// 마커 제거
		function removeMarkers() {
			for (let i = 0; i < markers.length; i++) {
				markers[i].setMap(null);
			}
			markers = []; // 이제 빈 배열로 재할당 가능
		}

		// 인포윈도우 표시
		function displayInfoWindow(marker, title) {
			const content = `<div style="padding:5px;z-index:1;">${title}</div>`;
			infoWindow.setContent(content);
			infoWindow.open(map, marker);
		}

		// 자식 노드 전체 제거
		function removeAllChildNodes(el) {
			while (el.hasChildNodes()) {
				el.removeChild(el.lastChild);
			}
		}
	</script>
</body>

</html>